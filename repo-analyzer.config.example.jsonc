{
  // Output directory for all generated reports (relative or absolute path)
  // All analysis outputs will be written to this directory
  "output_dir": "repo-analysis-output",

  // Dry-run mode: if true, shows what would be done without writing files
  // Useful for previewing analysis before committing to file generation
  "dry_run": false,

  // Directory tree generation configuration
  "tree_config": {
    // Maximum depth to traverse (null = unlimited)
    // Set a number to limit tree depth: e.g., 3 for three levels deep
    "max_depth": null,

    // Patterns to exclude from tree traversal
    // Supports exact matches and wildcards (*.ext)
    // Common exclusions: build artifacts, dependencies, caches
    "exclude_patterns": [
      ".git",           // Git internal directory
      "__pycache__",    // Python bytecode cache
      "*.pyc",          // Python compiled files
      "node_modules",   // Node.js dependencies
      ".venv",          // Python virtual environment
      "venv"            // Alternative Python virtual environment name
    ]
  },

  // File summary generation configuration
  "file_summary_config": {
    // Maximum file size in KB for expensive parsing operations
    // Files larger than this will skip declaration parsing but still report basic metrics
    // Default: 1024 (1 MB)
    "max_file_size_kb": 1024,

    // File patterns to include in analysis (glob patterns)
    // Only files matching these patterns will be analyzed
    // If empty or not specified, patterns will be auto-generated from enabled languages
    "include_patterns": [
      "*.py",      // Python files
      "*.js",      // JavaScript files
      "*.ts",      // TypeScript files
      "*.java",    // Java files
      "*.go",      // Go files
      "*.rs"       // Rust files
    ],

    // Detail level controls the amount of information in output
    // Options:
    //   "minimal"  - Basic fields: path, language, role, role_justification, summary
    //   "standard" - Adds metrics: file size, LOC, TODO count (RECOMMENDED)
    //   "detailed" - Adds structure parsing and external dependencies
    //
    // Recommendation: Use "standard" for most cases - it provides useful metrics
    // without the overhead of full structure parsing. Use "detailed" when you need
    // to analyze code structure or audit external dependencies.
    "detail_level": "standard",

    // Include legacy summary fields for backward compatibility with v1.0 consumers
    // When true, includes both "summary" and "summary_text" fields
    // When false, omits these fields for a cleaner v2.0-only format
    // Default: true (ensures compatibility)
    //
    // Set to false only if:
    // - You don't need v1.0 compatibility
    // - You want minimal JSON output size
    // - All consumers understand v2.0 schema
    "include_legacy_summary": true
  },

  // Dependency analysis configuration
  "dependency_config": {
    // Enable scanning of package management files
    // When true, looks for package files listed below
    "scan_package_files": true,

    // Package files to scan for external dependencies
    // These files declare project dependencies in various ecosystems
    "package_files": [
      "package.json",      // Node.js/npm dependencies
      "requirements.txt",  // Python pip dependencies
      "Pipfile",          // Python pipenv dependencies
      "pyproject.toml",   // Python modern dependencies (PEP 518)
      "go.mod",           // Go module dependencies
      "Cargo.toml"        // Rust cargo dependencies
    ]
  },

  // Language registry configuration
  // Controls which programming languages are analyzed and how they are detected
  "language_config": {
    // Explicitly enable specific languages (null = all languages enabled by default)
    // When set to a list, ONLY these languages will be analyzed
    // When null, all registered languages are enabled unless listed in disabled_languages
    //
    // Supported languages include:
    // - Python, JavaScript, TypeScript (with full parsing support)
    // - C, C++, C#, Rust, Go, Java, Swift (basic support, enhanced with tree-sitter/libclang)
    // - ASM (Assembly - .s, .S, .asm, .sx with .globl/.global label extraction)
    // - Perl (.pl, .pm, .perl with use/require dependency extraction)
    // - HTML, CSS, SQL (basic support)
    // - And many more (see language_registry.py for full list)
    //
    // Example to analyze only Python and JavaScript:
    // "enabled_languages": ["Python", "JavaScript"]
    "enabled_languages": null,

    // Explicitly disable specific languages
    // These languages will not be analyzed even if matched by include_patterns
    // Useful for excluding languages you don't want to track
    //
    // Example to exclude Ruby and PHP:
    // "disabled_languages": ["Ruby", "PHP"]
    "disabled_languages": [],

    // Language-specific overrides
    // Fine-tune individual language settings including priority and enabled status
    // Priority determines which language wins for shared extensions (e.g., .h for C/C++)
    // Higher priority = preferred for ambiguous extensions
    //
    // Example to give Python higher priority and disable Ruby:
    // "language_overrides": {
    //   "Python": {"priority": 15, "enabled": true},
    //   "Ruby": {"enabled": false}
    // }
    "language_overrides": {}
  },

  // Parser configuration for low-level language support
  // Controls structured parser integrations (tree-sitter, libclang) vs regex fallbacks
  "parser_config": {
    // Enable structured parsing (tree-sitter, libclang) when available
    // When false, falls back to regex-based heuristics
    // When true (default), attempts to use structured parsers if installed
    "enable_structured_parsers": true,

    // Cache parsed results for performance
    // Highly recommended for large codebases with repeated analysis
    "enable_parser_cache": true,

    // Parser-specific settings
    "parsers": {
      // Tree-sitter configuration (for Rust, C, C++, Perl with tree-sitter-<lang> grammars)
      "tree_sitter": {
        "enabled": true,
        // Installation: pip install tree-sitter tree-sitter-<language>
        // Example: pip install tree-sitter tree-sitter-rust tree-sitter-c
        "graceful_degradation": true  // Fall back to regex if unavailable
      },

      // Libclang configuration (for C/C++ with libclang Python bindings)
      "libclang": {
        "enabled": true,
        // Installation: pip install libclang
        // Requires libclang shared library (system package or conda)
        "graceful_degradation": true  // Fall back to tree-sitter or regex if unavailable
      }
    },

    // Language-specific parser preferences
    // Controls which parser to prefer for each language when multiple are available
    "language_parser_preferences": {
      "C": ["libclang", "tree_sitter", "regex"],      // Prefer libclang for C
      "C++": ["libclang", "tree_sitter", "regex"],    // Prefer libclang for C++
      "Rust": ["tree_sitter", "regex"],               // Prefer tree-sitter for Rust
      "Perl": ["tree_sitter", "regex"],               // Prefer tree-sitter for Perl
      "ASM": ["regex"]                                 // Assembly always uses regex
    },

    // Performance tuning
    "performance": {
      // Skip expensive parsing for files larger than this (KB)
      // These files will use regex fallback regardless of parser availability
      "max_file_size_for_structured_parsing_kb": 512,

      // Maximum time to spend parsing a single file (seconds)
      // If parsing exceeds this, fall back to regex
      "max_parse_time_seconds": 5.0
    }
  }
}
